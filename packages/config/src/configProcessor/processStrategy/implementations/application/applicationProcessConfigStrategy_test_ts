import { AzionConfig } from '../../../../types';
import ApplicationProcessConfigStrategy from './applicationProcessConfigStrategy';
import CacheProcessConfigStrategy from './cacheProcessConfigStrategy';
import DeviceGroupsProcessConfigStrategy from './deviceGroupsProcessConfigStrategy';
import FunctionInstancesProcessConfigStrategy from './functionInstancesProcessConfigStrategy';
import RulesProcessConfigStrategy from './rulesProcessConfigStrategy';

// Mock the dependent strategies
jest.mock('./cacheProcessConfigStrategy');
jest.mock('./rulesProcessConfigStrategy');
jest.mock('./deviceGroupsProcessConfigStrategy');
jest.mock('./functionInstancesProcessConfigStrategy');

describe('ApplicationProcessConfigStrategy', () => {
  let strategy: ApplicationProcessConfigStrategy;
  let mockCacheStrategy: jest.Mocked<CacheProcessConfigStrategy>;
  let mockRulesStrategy: jest.Mocked<RulesProcessConfigStrategy>;
  let mockDeviceGroupsStrategy: jest.Mocked<DeviceGroupsProcessConfigStrategy>;
  let mockFunctionInstancesStrategy: jest.Mocked<FunctionInstancesProcessConfigStrategy>;

  beforeEach(() => {
    // Clear all mocks
    jest.clearAllMocks();

    // Setup mock implementations
    mockCacheStrategy = new CacheProcessConfigStrategy() as jest.Mocked<CacheProcessConfigStrategy>;
    mockRulesStrategy = new RulesProcessConfigStrategy() as jest.Mocked<RulesProcessConfigStrategy>;
    mockDeviceGroupsStrategy = new DeviceGroupsProcessConfigStrategy() as jest.Mocked<DeviceGroupsProcessConfigStrategy>;
    mockFunctionInstancesStrategy = new FunctionInstancesProcessConfigStrategy() as jest.Mocked<FunctionInstancesProcessConfigStrategy>;

    // Initialize the mocks with default implementations
    (CacheProcessConfigStrategy as jest.Mock).mockImplementation(() => mockCacheStrategy);
    (RulesProcessConfigStrategy as jest.Mock).mockImplementation(() => mockRulesStrategy);
    (DeviceGroupsProcessConfigStrategy as jest.Mock).mockImplementation(() => mockDeviceGroupsStrategy);
    (FunctionInstancesProcessConfigStrategy as jest.Mock).mockImplementation(() => mockFunctionInstancesStrategy);

    // Create the strategy instance
    strategy = new ApplicationProcessConfigStrategy();
  });

  describe('transformToManifest', () => {
    it('should return empty array when no applications are provided', () => {
      const config: AzionConfig = {};
      const result = strategy.transformToManifest(config);
      expect(result).toEqual([]);
    });

    it('should return empty array when applications array is empty', () => {
      const config: AzionConfig = { applications: [] };
      const result = strategy.transformToManifest(config);
      expect(result).toEqual([]);
    });

    it('should transform a basic application configuration to manifest format with default values', () => {
      const config: AzionConfig = {
        applications: [
          {
            name: 'test-application',
          },
        ],
      };

      const result = strategy.transformToManifest(config);

      expect(result).toEqual([
        {
          name: 'test-application',
          active: true,
          debug: false,
          modules: {
            cache: {
              enabled: true,
            },
            functions: {
              enabled: false,
            },
            application_accelerator: {
              enabled: true,
            },
            image_processor: {
              enabled: false,
            },
          },
        },
      ]);
    });

    it('should transform a complete application configuration to manifest format', () => {
      // Mock return values for the strategy methods
      mockCacheStrategy.transformToManifest.mockReturnValue([{
        name: 'test-cache',
        browser_cache: { behavior: 'override', max_age: 3600 },
        modules: {
          cache: {
            behavior: 'override',
            max_age: 60,
            stale_cache: { enabled: false },
            large_file_cache: { enabled: false, offset: 1024 },
            tiered_cache: { enabled: false, topology: 'near-edge' }
          },
          application_accelerator: {
            cache_vary_by_method: [],
            cache_vary_by_querystring: { behavior: 'ignore', fields: [], sort_enabled: false },
            cache_vary_by_cookies: { behavior: 'ignore', cookie_names: [] },
            cache_vary_by_devices: { behavior: 'ignore', device_group: [] }
          }
        }
      }]);
      mockRulesStrategy.transformToManifest.mockReturnValue([{
        phase: 'request',
        rule: {
          name: 'test-rule',
          active: true,
          criteria: [[{ variable: '${request_uri}', conditional: 'if', operator: 'is_equal', argument: '/test' }]],
          behaviors: [{ type: 'deliver' }]
        }
      }]);
      mockDeviceGroupsStrategy.transformToManifest.mockReturnValue([{
        name: 'test-device-group',
        user_agent: 'test-agent'
      }]);
      mockFunctionInstancesStrategy.transformToManifest.mockReturnValue([{
        name: 'test-function-instance',
        function: 'test-function',
        args: {},
        active: true
      }]);

      const config: AzionConfig = {
        applications: [
          {
            name: 'complete-application',
            active: false,
            debug: true,
            edgeCacheEnabled: false,
            functionsEnabled: true,
            applicationAcceleratorEnabled: false,
            imageProcessorEnabled: true,
            cache: [{ 
              name: 'test-cache', 
              browser: { maxAgeSeconds: 3600 },
              tiered_cache: {
                enabled: true,
                topology: 'global'
              }
            }],
            rules: { request: [], response: [] },
            deviceGroups: [{ name: 'test-device-group', userAgent: 'test-agent' }],
            functionsInstances: [{ name: 'test-function-instance', ref: 'test-function' }],
          },
        ],
        functions: [{ name: 'test-function', path: './functions/test-function.js' }],
        connectors: [],
      };

      const result = strategy.transformToManifest(config);

      expect(result).toEqual([
        {
          name: 'complete-application',
          active: false,
          debug: true,
          modules: {
            cache: {
              enabled: false,
              tiered_cache: {
                enabled: true,
                topology: 'near-edge'
              }
            },
            functions: {
              enabled: true,
            },
            application_accelerator: {
              enabled: false,
            },
            image_processor: {
              enabled: true,
            },
          },
          cache_settings: [{
            name: 'test-cache',
            browser_cache: { behavior: 'override', max_age: 3600 },
            modules: {
              cache: {
                behavior: 'override',
                max_age: 60,
                stale_cache: { enabled: false },
                large_file_cache: { enabled: false, offset: 1024 },
                tiered_cache: { enabled: false, topology: 'near-edge' }
              },
              application_accelerator: {
                cache_vary_by_method: [],
                cache_vary_by_querystring: { behavior: 'ignore', fields: [], sort_enabled: false },
                cache_vary_by_cookies: { behavior: 'ignore', cookie_names: [] },
                cache_vary_by_devices: { behavior: 'ignore', device_group: [] }
              }
            }
          }],
          rules: [{
            phase: 'request',
            rule: {
              name: 'test-rule',
              active: true,
              criteria: [[{ variable: '${request_uri}', conditional: 'if', operator: 'is_equal', argument: '/test' }]],
              behaviors: [{ type: 'deliver' }]
            }
          }],
          device_groups: [{
            name: 'test-device-group',
            user_agent: 'test-agent'
          }],
          functions_instances: [{
            name: 'test-function-instance',
            function: 'test-function',
            args: {},
            active: true
          }],
        },
      ]);

      // Verify that the strategy methods were called with the correct parameters
      expect(mockCacheStrategy.transformToManifest).toHaveBeenCalledWith([
        { name: 'test-cache', browser: { maxAgeSeconds: 3600 } },
      ]);
      expect(mockRulesStrategy.transformToManifest).toHaveBeenCalledWith(
        { request: [], response: [] },
        [{ name: 'test-function', path: './functions/test-function.js' }],
        []
      );
      expect(mockDeviceGroupsStrategy.transformToManifest).toHaveBeenCalledWith([
        { name: 'test-device-group', userAgent: 'test-agent' },
      ]);
      expect(mockFunctionInstancesStrategy.transformToManifest).toHaveBeenCalledWith(
        [{ name: 'test-function-instance', ref: 'test-function' }],
        config
      );
    });

    it('should handle functions enabled based on functionsInstances presence', () => {
      const config: AzionConfig = {
        applications: [
          {
            name: 'app-with-function-instances',
            functionsInstances: [{ name: 'test-function-instance', ref: 'test-function' }],
          },
        ],
      };

      mockFunctionInstancesStrategy.transformToManifest.mockReturnValue([{
        name: 'test-function-instance',
        function: 'test-function',
        args: {},
        active: true
      }]);

      const result = strategy.transformToManifest(config);

      expect(result[0].modules.functions.enabled).toBe(true);
    });

    it('should transform multiple applications to manifest format', () => {
      const config: AzionConfig = {
        applications: [
          {
            name: 'app-1',
          },
          {
            name: 'app-2',
            active: false,
          },
        ],
      };

      const result = strategy.transformToManifest(config);

      expect(result).toHaveLength(2);
      expect(result[0].name).toBe('app-1');
      expect(result[1].name).toBe('app-2');
      expect(result[0].active).toBe(true);
      expect(result[1].active).toBe(false);
    });
  });

  describe('transformToConfig', () => {
    it('should return empty array when no applications are provided', () => {
      const payload = {};
      const transformedPayload: AzionConfig = {};

      const result = strategy.transformToConfig(payload, transformedPayload);

      expect(result).toEqual([]);
      expect(transformedPayload.applications).toEqual([]);
    });

    it('should return empty array when applications array is empty', () => {
      const payload = { applications: [] };
      const transformedPayload: AzionConfig = {};

      const result = strategy.transformToConfig(payload, transformedPayload);

      expect(result).toEqual([]);
      expect(transformedPayload.applications).toEqual([]);
    });

    it('should transform a basic application manifest to config format', () => {
      const payload = {
        applications: [
          {
            name: 'test-application',
            active: true,
            debug: false,
            modules: {
              cache: {
                enabled: true,
              },
              functions: {
                enabled: false,
              },
              application_accelerator: {
                enabled: true,
              },
              image_processor: {
                enabled: false,
              },
            },
          },
        ],
      };
      const transformedPayload: AzionConfig = {};

      strategy.transformToConfig(payload, transformedPayload);

      expect(transformedPayload.applications).toEqual([
        {
          name: 'test-application',
          active: true,
          debug: false,
          edgeCacheEnabled: true,
          functionsEnabled: false,
          applicationAcceleratorEnabled: true,
          imageProcessorEnabled: false,
          cache: undefined,
          rules: undefined,
          deviceGroups: undefined,
          functionsInstances: undefined,
        },
      ]);
    });

    it('should transform a complete application manifest to config format', () => {
      // Mock return values for the strategy methods
      mockCacheStrategy.transformToConfig.mockReturnValue([{ name: 'test-cache', browser: { maxAgeSeconds: 3600 } }]);
      mockRulesStrategy.transformToConfig.mockReturnValue({ request: [], response: [] });
      mockDeviceGroupsStrategy.transformToConfig.mockReturnValue([{ name: 'test-device-group', userAgent: 'test-agent' }]);
      mockFunctionInstancesStrategy.transformToConfig.mockReturnValue([{ name: 'test-function-instance', ref: 'test-function' }]);

      const payload = {
        applications: [
          {
            name: 'complete-application',
            active: false,
            debug: true,
            modules: {
              cache: {
                enabled: false,
                tiered_cache: {
                  enabled: true,
                  topology: 'near-edge'
                }
              },
              functions: {
                enabled: true,
              },
              application_accelerator: {
                enabled: false,
              },
              image_processor: {
                enabled: true,
              },
            },
            cache_settings: [{ name: 'test-cache' }],
            rules: [{ name: 'test-rule' }],
            device_groups: [{ name: 'test-device-group' }],
            functions_instances: [{ name: 'test-function-instance' }],
          },
        ],
      };
      const transformedPayload: AzionConfig = {};

      strategy.transformToConfig(payload, transformedPayload);

      expect(transformedPayload.applications).toEqual([
        {
          name: 'complete-application',
          active: false,
          debug: true,
          edgeCacheEnabled: false,
          functionsEnabled: true,
          applicationAcceleratorEnabled: false,
          imageProcessorEnabled: true,
          cache: [{ name: 'test-cache', browser: { maxAgeSeconds: 3600 } }],
          rules: { request: [], response: [] },
          deviceGroups: [{ name: 'test-device-group', userAgent: 'test-agent' }],
          functionsInstances: [{ name: 'test-function-instance', ref: 'test-function' }],
        },
      ]);

      // Verify that the strategy methods were called with the correct parameters
      expect(mockCacheStrategy.transformToConfig).toHaveBeenCalledWith([{ name: 'test-cache' }]);
      expect(mockRulesStrategy.transformToConfig).toHaveBeenCalledWith([{ name: 'test-rule' }]);
      expect(mockDeviceGroupsStrategy.transformToConfig).toHaveBeenCalledWith([{ name: 'test-device-group' }]);
      expect(mockFunctionInstancesStrategy.transformToConfig).toHaveBeenCalledWith([{ name: 'test-function-instance' }]);
    });

    it('should handle undefined optional properties', () => {
      const payload = {
        applications: [
          {
            name: 'minimal-application',
            modules: {},
          },
        ],
      };
      const transformedPayload: AzionConfig = {};

      strategy.transformToConfig(payload, transformedPayload);

      expect(transformedPayload.applications).toEqual([
        {
          name: 'minimal-application',
          active: undefined,
          debug: undefined,
          edgeCacheEnabled: undefined,
          functionsEnabled: undefined,
          applicationAcceleratorEnabled: undefined,
          imageProcessorEnabled: undefined,
          cache: undefined,
          rules: undefined,
          deviceGroups: undefined,
          functionsInstances: undefined,
        },
      ]);
    });

    it('should transform multiple application manifests to config format', () => {
      const payload = {
        applications: [
          {
            name: 'app-1',
            active: true,
            modules: {
              cache: { enabled: true },
            },
          },
          {
            name: 'app-2',
            active: false,
            modules: {
              functions: { enabled: true },
            },
          },
        ],
      };
      const transformedPayload: AzionConfig = {};

      strategy.transformToConfig(payload, transformedPayload);

      expect(transformedPayload.applications).toHaveLength(2);
      expect(transformedPayload.applications![0].name).toBe('app-1');
      expect(transformedPayload.applications![1].name).toBe('app-2');
      expect(transformedPayload.applications![0].active).toBe(true);
      expect(transformedPayload.applications![1].active).toBe(false);
      expect(transformedPayload.applications![0].edgeCacheEnabled).toBe(true);
      expect(transformedPayload.applications![1].functionsEnabled).toBe(true);
    });
  });
});
